// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Receipt Processor
 *
 * A simple receipt processor
 *
 * API version: 1.0.0
 */

package openapi

import (
	"regexp"
	"errors"
	"fmt"
)

type Item struct {

	// The Short Product Description for the item.
	ShortDescription string `json:"shortDescription" validate:"regexp=^[\\\\w\\\\s\\\\-]+$"`

	// The total price payed for this item.
	Price string `json:"price" validate:"regexp=^\\\\d+\\\\.\\\\d{2}$"`
}

// AssertItemRequired checks if the required fields are not zero-ed
func AssertItemRequired(obj Item) error {
	elements := map[string]interface{}{
		"shortDescription": obj.ShortDescription,
		"price": obj.Price,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	return nil
}

// AssertItemConstraints checks if the values respects the defined constraints
func AssertItemConstraints(obj Item) error {
	// -------------------- START Manual edits -------------------------------- //
	// openapi-generator doesn't seem to actually generate code that validates
	// if passed fields are formatted correctly according to their 'pattern'
	// hence I had to manually edit this file to add format checking 

	descRe := regexp.MustCompile("^[\\w\\s\\-]+$") 
	descIsValid := descRe.MatchString(obj.ShortDescription)
	
	if !descIsValid {
		err := errors.New(fmt.Sprint("Validation error: item 'description' should only contain alphanumeric chars, whitespaces, '_', or '-'", obj.ShortDescription))
		return err
	}
	
	priceRe := regexp.MustCompile(`^\d+\.\d{2}$`)
	priceIsFormatted := priceRe.MatchString(obj.Price)
	if !priceIsFormatted {
		err := errors.New(fmt.Sprintf("Validation error: item '%s' has invalid 'price': %s, it should be in the format 000(...)00.00", obj.ShortDescription, obj.Price))
		return err
	}
	// -------------------- END Manual edits ---------------------------------- //
	
	return nil
}
