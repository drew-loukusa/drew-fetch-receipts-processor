// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Receipt Processor
 *
 * A simple receipt processor
 *
 * API version: 1.0.0
 */

package openapi

import (
	"regexp"
	"errors"
	"log"
	"fmt"
	"time"
)

type Receipt struct {

	// The name of the retailer or store the receipt is from.
	Retailer string `json:"retailer" validate:"regexp=^[\\\\w\\\\s\\\\-&]+$"`

	// The date of the purchase printed on the receipt.
	PurchaseDate string `json:"purchaseDate"`

	// The time of the purchase printed on the receipt. 24-hour time expected.
	PurchaseTime string `json:"purchaseTime"`

	Items []Item `json:"items"`

	// The total amount paid on the receipt.
	Total string `json:"total" validate:"regexp=^\\\\d+\\\\.\\\\d{2}$"`
}

// AssertReceiptRequired checks if the required fields are not zero-ed
func AssertReceiptRequired(obj Receipt) error {
	elements := map[string]interface{}{
		"retailer": obj.Retailer,
		"purchaseDate": obj.PurchaseDate,
		"purchaseTime": obj.PurchaseTime,
		"items": obj.Items,
		"total": obj.Total,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	for _, el := range obj.Items {
		if err := AssertItemRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertReceiptConstraints checks if the values respects the defined constraints
func AssertReceiptConstraints(obj Receipt) error {
	
	// -------------------- START Manual edits -------------------------------- //
	// openapi-generator doesn't seem to actually generate code that validates
	// if passed fields are formatted correctly according to their 'pattern'
	// hence I had to manually edit this file to add format checking 

	retailerRe :=  regexp.MustCompile(`^[\w\s\-&]+$`)
	retailerFormatValid := retailerRe.MatchString(obj.Retailer)
	if !retailerFormatValid {
		err := errors.New(fmt.Sprintf("Validation error: 'retailer' should only contain alphanumeric chars, spaces, '-' and '&': '%s'", obj.Retailer))
		log.Println(err)
		return err
	}
	
	_, dateParseErr := time.Parse("2006-01-02", obj.PurchaseDate)
	if dateParseErr != nil {
		err := errors.New(fmt.Sprint("Validation error: invalid 'purchaseDate' format: ", dateParseErr.Error()))
		log.Println(err)
		return err
	}

	_, timeParseErr := time.Parse("15:04", obj.PurchaseTime)
	if timeParseErr != nil {
		err := errors.New(fmt.Sprint("Validation error: invalid 'purchaseTime' format: ", timeParseErr.Error()))
		log.Println(err)
		return err
	}

	totalRe := regexp.MustCompile(`^\d+\.\d{2}$`)
	totalIsFormatted := totalRe.MatchString(obj.Total)
	if !totalIsFormatted {
		err := errors.New(fmt.Sprint("Validation error: invalid 'total' format, it should be in the format 000(...)00.00: ", obj.Total))
		return err
	}

	// -------------------- END Manual edits ---------------------------------- //

	for _, el := range obj.Items {
		if err := AssertItemConstraints(el); err != nil {
			return err
		}
	}

	return nil
}
